# Curso de FastAPI do ZERO com o ü¶ñ Dunossauro
FastAPI √© um framework Python moderno, projetado para simplicidade, velocidade e efici√™ncia. A combina√ß√£o de diversas funcionalidades modernas do Python como anota√ß√µes de tipo e suporte a concorr√™ncia, facilitando o desenvolvimento de APIs.

# Aula 01 Configurando o Ambiente de Desenvolvimento
## Configurando o Ambiente de Desenvolvimento

Verificando a instala√ß√£o do Python.
~~~shell
python --version
~~~

Instala√ß√£o do pyenv no Windows, recomendo usar o pyenv-windows.
~~~shell
Invoke-WebRequest -UseBasicParsing -Uri "https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1" -OutFile "./install-pyenv-win.ps1"; &"./install-pyenv-win.ps1"
~~~

Ap√≥s o pyenv-windows instalado, verificar qual vers√£o do python deseja e instale.
~~~shell
pyenv update
pyenv install 3.12:latest
~~~

Definiar uma vers√£o global do Python.
~~~shell
pyenv global 3.12.x
~~~

Instala√ß√£o de ferramentas recomendadas.
~~~shell
pip install pipx
~~~

~~~shell
pipx install poetry
~~~

Ap√≥s o poetry instalado √© necess√°rio executar o comando abaixo, feche e reabra o terminal:
~~~shell
pipx ensurepath
~~~

~~~shell
pipx install ignr
~~~

## Cria√ß√£o do Projeto FastAPI e Instala√ß√£o das Depend√™ncias
Entrar no diret√≥rio onde criar√° o projeto.
~~~shell
cd C:\projetos\projetos-GIT\
~~~

Criando o projeto.
~~~shell
poetry new fast_zero_v2
~~~

Entrar no projeto.
~~~shell
cd fast_zero_v2
~~~

Definir qual a vers√£o do Python ser√° utilizada nesse projeto/diret√≥rio. O script abaixo criar√° um arquivo que cont√©m a vers√£o do Python.
~~~shell
pyenv local 3.12.4
~~~

Esse comando criar√° um arquivo oculto chamado `.python-version` na raiz do projeto.

Configurar o arquivo `pyproject.toml`.
[...]

Crie o ambiente virtual do projeto.
~~~shell
poetry install
~~~

Instalando a biblioteca Python do FastAPI.
~~~shell
poetry add fastapi
~~~

## Primeira Execu√ß√£o de um "Hello, World!"
Cria√ß√£o do app.
~~~shell
echo > fast_zero_v2/app.py
~~~
[melhorar esta cria√ß√£o pelo terminal]


Acessando e codificando no app.
~~~shell
code fast_zero_v2/app.py
~~~
[... codificando ...]

Executar a fun√ß√£o pelo terminal em modo interativo para chamar a fun√ß√£o.
~~~shell
python -i .\fast_zero_v2\app.py
~~~

Depois execute a fun√ß√£o para obter o resultado.
~~~shell
>>> read_root()
~~~

[... codificando ...]

Antes de iniciar a aplica√ß√£o, habilitar o ambiente virtual, para que o python consiga enxergar as depend√™ncias instaladas.
~~~shell
poetry shell
~~~

## Testando o ambiente: iniciar nosso servidor FastAPI para iniciar nossa aplica√ß√£o
~~~shell
fastapi dev fast_zero_v2/app.py
~~~

## Instalando + ferramentas de desenvolvimento
~~~shell
poetry add --group dev pytest pytest-cov taskipy ruff httpx
~~~

Ap√≥s a instala√ß√£o das ferramentas de desenvolvimento, precisamos definir as configura√ß√µes de cada uma individualmente no arquivo `pyproject.toml`.
[... atentar para os nomes dos projetos que influencia neste arqvuivo ...]


Ap√≥s arquivo configurado, pode testar os comandos criados para o taskipy:
~~~shell
task lint
~~~

~~~shell
task format
~~~

~~~shell
task lint
~~~

## Introdu√ß√£o ao Pytest: Testando o "Hello, World!"
~~~shell
task test
~~~

Gera um relat√≥rio de cobertura de testes em formato HTML. Pode abrir esse arquivo no navegador e entender exatamente quais linhas do c√≥digo n√£o est√£o sendo testadas.
~~~shell
coverage html
~~~

### Escrevendo o teste
Cria√ß√£o dos arquivos de teste.
~~~shell
echo > tests/test_app.py
~~~
[...]

~~~shell
task test
~~~

Por n√£o coletar nenhum teste, o pytest ainda retornou um "erro". Para ver a cobertura, precisaremos executar novamente o post_test manualmente:
~~~shell
task post_test
~~~

### Criando nosso reposit√≥rio no git

[... deu muito ruim nessa parte do git, refazer outro projeto com cuidado]

Criar um arquivo `.gitignore` para n√£o adicionar o ambiente virtual e outros arquivos desnecess√°rios no versionamento de c√≥digo.
~~~shell
ignr -p python > .gitignore
~~~

Criar um novo reposit√≥rio no Git local para versionar o c√≥digo e definir a branch main como padr√£o.
~~~shell
git init -b main
~~~


Para criar um reposit√≥rio remoto no GitHub externo caso n√£o exista.
~~~shell
gh repo create
~~~


#### Respostas do gh
- Create a new repository on GitHub from scratch
- fast_zero_sync_v2
- C√≥digo das aulas aprendidas no curso do Dunossauro (FASTAPI)
- Public
- N
- N
- y
- GNU General Public License v3.0
- Y
- Y

~~~shell
git remote add origin https://github.com/LuizPerciliano/fast_zero_sync_v2.git
~~~

~~~shell
git pull origin main
~~~

~~~shell
git add .
~~~

~~~shell
git commit -m "Configura√ß√£o inicial do projeto"
~~~

~~~shell
git push
~~~

[... deu muito ruim nessa parte do git, refazer outro projeto com cuidado]



# Aula 02 Introdu√ß√£o ao desenvolvimento WEB

## Usando o fastapi na rede local
~~~shell
fastapi dev fast_zero_v2/app.py --host 0.0.0.0
~~~

ou com o comando abaixo para o mesmo resultado
~~~shell
task run --host 0.0.0.0
~~~

Assim, voc√™ pode acessar a aplica√ß√£o de outro computador na sua rede usando o endere√ßo IP da sua m√°quina.

Descobrindo o ip local no Windows
~~~shell
ipconfig
~~~

Descobrindo o seu endere√ßo local usando python pelo interpretador
~~~shell
python
~~~

~~~python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(("8.8.8.8", 80))
s.getsockname()[0]
~~~


Agora basta acessar a aplica√ß√£o pelo endere√ßo: http://192.168.0.5:8000/, ficando acess√≠vel tamb√©m por outras m√°quinas dentro dessa rede, assim como o celular.

[... desenvolvendo e incrementando o projeto ...]


Criando novo arquivo para testes e aprendizado de endpoints.
~~~shell
type nul > fast_zero_v2/aula_00.py
~~~

Abrir o arquivo `fast_zero_v2/aula_00.py` e copiar o script abaixo.
~~~python
from fastapi import FastAPI
from fastapi.responses import HTMLResponse

app = FastAPI()


@app.get('/')
def read_root():
    return {'message': 'Ol√° Mundo!'}
~~~

Executar o arquivo espec√≠fico.
~~~shell
fastapi dev fast_zero_v2/aula_00.py
~~~

## Pydantic
~~~shell
echo > fast_zero_v2/schemas.py
~~~

[... desenvolvendo e incrementando o projeto ...]


# Aula 03 Estruturando o Projeto e Criando Rotas CRUD
## Implementando endpoints

### Rota do POST
Arquivo `fast_zero_v2/app.py`.
~~~python
@app.post('/users/', status_code=HTTPStatus.CREATED)
def create_user():
    ...
~~~

### Modelo de dados
Arquivo `fast_zero_v2/schemas.py`.
~~~python
class UserSchema(BaseModel):
    username: str
    email: str
    password: str
~~~

[... desenvolvendo e incrementando o projeto ... estudar mais esta aula]

## Valida√ß√£o e pydantic

Valida√ß√£o de email
Instalando + ferramentas de desenvolvimento 
~~~shell
poetry add "pydantic[email]"
~~~

## Criando um banco de dados falso


### N√£o se repita (DRY)
Arquivo `tests/conftest.py`.

~~~shell
echo > tests/conftest.py
~~~

## Implementando a Rota GET


## Implementando a Rota PUT

## Implementando a Rota DELETE

# Aula 04 Configurando o Banco de Dados e Gerenciando Migra√ß√µes com Alembic

Instalando + ferramentas de desenvolvimento 
~~~shell
poetry add sqlalchemy
~~~

~~~shell
poetry add pydantic-settings
~~~

Agora definiremos nosso modelo User. No diret√≥rio fast_zero, crie um novo arquivo chamado models.py e incluiremos o seguinte c√≥digo no arquivo:

~~~shell
echo > fast_zero_v2/models.py
~~~
[...]

## Testando as Tabelas
Criaremos uma fixture para a conex√£o com o banco de dados chamada session no arquivo `tests/conftest.py`.
[...]

### Criando um Teste para a Nossa Tabela
Agora, no arquivo test_db.py, escreveremos um teste para a cria√ß√£o de um usu√°rio. Este teste adiciona um novo usu√°rio ao banco de dados, faz commit das mudan√ßas, e depois verifica se o usu√°rio foi devidamente criado consultando-o pelo nome de usu√°rio. Se o usu√°rio foi criado corretamente, o teste passa. Caso contr√°rio, o teste falha, indicando que h√° algo errado com nossa fun√ß√£o de cria√ß√£o de usu√°rio.

~~~shell
echo > tests/test_db.py
~~~
[...]

#### Executando o teste

~~~shell
exit
~~~

~~~shell
task format
~~~

~~~shell
task test
~~~

O ideal √© ter pelo menos dois terminais ativos, um para rodar a aplica√ß√£o e outro para os testes e demais comandos.
~~~shell
task run
~~~

## Configura√ß√£o do ambiente do banco de dados
~~~shell
echo > fast_zero_v2/settings.py
~~~
[...]

Agora, definiremos o DATABASE_URL no nosso arquivo de ambiente .env. Crie o arquivo na raiz do projeto e adicione a seguinte linha:
~~~shell
echo > .env
~~~
[...]

~~~shell
echo 'database.db' >> .gitignore
~~~

## Instalando o Alembic e Criando a Primeira Migra√ß√£o
~~~shell
poetry add alembic
~~~

Ap√≥s a instala√ß√£o do Alembic, precisamos inici√°-lo em nosso projeto. O comando de inicializa√ß√£o criar√° um diret√≥rio migrations e um arquivo de configura√ß√£o alembic.ini:
~~~shell
alembic init migrations
~~~

### Criando uma migra√ß√£o autom√°tica
Com o Alembic devidamente instalado e iniciado, agora √© o momento de gerar nossa primeira migra√ß√£o. Mas, antes disso, precisamos garantir que o Alembic consiga acessar nossas configura√ß√µes e modelos corretamente. Para isso, faremos algumas altera√ß√µes no arquivo migrations/env.py.
[...]

Para criar a migra√ß√£o, utilizamos o seguinte comando:
~~~shell
alembic revision --autogenerate -m "create users table"
~~~

### Analisando a migra√ß√£o autom√°tica
Vamos abrir e analisar o arquivo de migra√ß√£o `migrations/versions/f3577cecc9f1_create_users_table.py`.

~~~shell
code migrations/versions/f3577cecc9f1_create_users_table.py
~~~

Vamos acessar o console do sqlite e verificar se isso foi feito. Precisamos chamar sqlite3 nome_do_arquivo.db ou usar uma aplicativo que abre diversos tipos de banco de dados como o DBeaver:
~~~shell
sqlite3 database.db
~~~
[...]


Para aplicar as migra√ß√µes, usamos o comando upgrade do CLI Alembic. O argumento head indica que queremos aplicar todas as migra√ß√µes que ainda n√£o foram aplicadas:
~~~shell
alembic upgrade head
~~~
[...]


Agora, se examinarmos nosso banco de dados novamente:
[...]

## Commit
Primeiro, verificaremos o status do nosso reposit√≥rio para ver as mudan√ßas que fizemos:
~~~shell
git status
~~~

~~~shell
git add . 
~~~

![alt text](image.png)

~~~shell
git commit -m "Adicionada a primeira migra√ß√£o com Alembic. Criada tabela de usu√°rios."
~~~

~~~shell
git push
~~~


# Aula 05 Integrando Banco de Dados a API
Para isso, criaremos a fun√ß√£o get_session e tamb√©m definiremos Session no arquivo `database.py`.
~~~shell
echo > .\fast_zero_v2\database.py
~~~

## Modificando o Endpoint POST /users
[...]

### Testando o Endpoint POST /users com Pytest e Fixtures
Alteraremos a nossa fixture client para substituir a fun√ß√£o get_session que estamos injetando no endpoint pela sess√£o do banco em mem√≥ria que j√° t√≠nhamos definido para banco de dados.
[...]

D√° erro, logo ...
[...]


## Modificando o Endpoint GET /users
[...]
### Testando o Endpoint GET /users
[...]
### Criando uma fixture para User
[...]

### Integrando o Schema ao Model
ajustando o arquivo `fast_zero/schemas.py` <p>
[...]

## Modificando o Endpoint PUT /users
[...]

### Adicionando o teste do PUT
[...]

## Modificando o Endpoint DELETE /users
[...]
### Adicionando testes para DELETE
[...]


## Atualizando o reposit√≥rio - Commit
Primeiro, verificar o status do reposit√≥rio para ver as mudan√ßas realizadas:
~~~shell
git status
~~~

Se tudo estiver ok, adicionar os arquivos, comitar e por fim enviar para o reposit√≥rio remoto.
~~~shell
git add . 
git commit -m "Revisando as aulas com um novo projeto criado.Atualizando endpoints para usar o banco de dados real."
git push
~~~



# Aula 06 Autentica√ß√£o e Autoriza√ß√£o com JWT
## Gerando tokens JWT
Para gerar tokens JWT, precisamos de duas bibliotecas extras: pyjwt e pwdlib. A primeira ser√° usada para a gera√ß√£o do token, enquanto a segunda ser√° usada para criptografar as senhas dos usu√°rios. Para instal√°-las, execute o seguinte comando no terminal:
~~~shell
poetry add pyjwt "pwdlib[argon2]"
~~~

Agora, criaremos uma fun√ß√£o para gerar nossos tokens JWT. Criaremos um novo arquivo para gerenciar a seguran√ßa: security.py. Nesse arquivo iniciaremos a gera√ß√£o dos tokens:

~~~shell
echo > .\fast_zero_v2\security.py
~~~

## Testando a gera√ß√£o de tokens
~~~shell
echo > .\tests\test_security.py
~~~

## Modificando o endpoint de POST para encriptar a senha
[...]

### Sobre o teste da POST /users/


## Modificando o endpoint de atualiza√ß√£o de usu√°rios

## Criando um endpoint de gera√ß√£o do token
### Utilizando OAuth2PasswordRequestForm
~~~shell
poetry add python-multipart
~~~

### Criando um endpoint de gera√ß√£o do token
[...]

### Testando /token

## Protegendo os Endpoints
[...]


### Aplica√ß√£o da prote√ß√£o ao endpoint

## Atualizando os Testes



## Atualizando o reposit√≥rio - Commit
Caso seja um reposit√≥rio de desenvolvimento compartilhado, verificar se no reposit√≥rio remoto h√° algo novo e pedir para baixar.
~~~shell
git pull
~~~

Verificar o status do reposit√≥rio para ver as mudan√ßas realizadas:
~~~shell
git status
~~~

Se tudo estiver ok, adicionar os arquivos, comitar e por fim enviar para o reposit√≥rio remoto.
~~~shell
git add . 
git commit -m "Revisando as aulas com um novo projeto criado. Aula 06. Protege os endpoints PUT e DELETE com autentica√ß√£o"
git push
~~~




# Aula 07 Refatorando a Estrutura do Projeto

## Criando Routers
Criaremos inicialmente uma nova estrutura de diret√≥rios chamada routers dentro do seu projeto fast_zero. Aqui, teremos subaplicativos dedicados a fun√ß√µes espec√≠ficas, como gerenciamento de usu√°rios e autentica√ß√£o.

‚îú‚îÄ‚îÄ fast_zero  
‚îÇ  ‚îú‚îÄ‚îÄ app.py  
‚îÇ  ‚îú‚îÄ‚îÄ database.py  
‚îÇ  ‚îú‚îÄ‚îÄ models.py  
‚îÇ  ‚îú‚îÄ‚îÄ routers  
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ auth.py  
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ users.py  

### Implementando um Router para Usu√°rios
~~~shell
mkdir routers
~~~

~~~shell
echo > fast_zero_v2\routers\users.py
~~~

### Criando um router para Auth
~~~shell
echo > fast_zero_v2\routers\auth.py
~~~


O comando abaixo deu erro, verificar*
~~~shell
task serve
~~~

#### Altera√ß√£o no teste do token
Arquivo `tests/test_app.py`



## Plugando as rotas em app

## Reestruturando os arquivos de testes

### Ajustando os testes para Auth
~~~shell
echo > tests\test_auth.py
~~~


### Ajustando os testes para User
~~~shell
echo > tests\test_users.py
~~~


#### Executando os testes
~~~shell
task test
~~~


Resolver o trauma abaixo*
![alt text](image-1.png)



## Refinando a Defini√ß√£o de Rotas com Annotated

## Movendo as constantes para vari√°veis de ambiente

### Adicionando as constantes a Settings

### Removendo as constantes do c√≥digo

## Testando se tudo funciona
~~~shell
task test
~~~

erro, meu Swagger n√£o aparece usu√°rios, verificar*
![alt text](image-2.png)

## Atualizando o reposit√≥rio - Commit
Caso seja um reposit√≥rio de desenvolvimento compartilhado, verificar se no reposit√≥rio remoto h√° algo novo e pedir para baixar.
~~~shell
git pull
~~~

Verificar o status do reposit√≥rio para ver as mudan√ßas realizadas:
~~~shell
git status
~~~

Se tudo estiver ok, adicionar os arquivos, comitar e por fim enviar para o reposit√≥rio remoto.
~~~shell
git add . 
git commit -m "Refatorando estrutura do projeto: Criado routers para Users e Auth; movido constantes para vari√°veis de ambiente." 
git push 
~~~








[üêç INICIO VOLTAR DAQUI ...üêç]
# Aula 08 Tornando o sistema de autentica√ß√£o robusto

## Testes para autentica√ß√£o

### Testando a altera√ß√£o de um usu√°rio n√£o autorizado

#### Criando modelos por demanda com factory-boy

O factory-boy √© uma biblioteca que nos permite criar objetos de modelo de teste de forma r√°pida e f√°cil. Com ele, podemos criar uma "f√°brica" de usu√°rios que produzir√° novos objetos de usu√°rio sempre que precisarmos. Isso nos permite criar m√∫ltiplos usu√°rios de teste com facilidade, o que √© perfeito para nosso cen√°rio atual.

~~~shell
poetry add --group dev factory-boy
~~~

Executando os testes abaixo em diante, o meu deu erro em alguns, logo, os testes seguintes n√£o foi poss√≠vel avaliar, verificar* (No final copiei tudo e vi que um arquivo precisava estar diferente, por√©m preciso rever sobre o token, pois isso est√° quebrando meus testes)

![alt text](image-3.png)


### Testando o DELETE com o usu√°rio errado


### Testando a expira√ß√£o do token


### Testando o usu√°rio n√£o existente e senha incorreta


#### Testando a exce√ß√£o para um usu√°rio inexistente


#### Testando a exce√ß√£o para uma senha incorreta



## Implementando o refresh do token



~~~shell
poetry add --group dev freezegun
~~~


## Atualizando o reposit√≥rio - Commit
Caso seja um reposit√≥rio de desenvolvimento compartilhado, verificar se no reposit√≥rio remoto h√° algo novo e pedir para baixar.
~~~shell
git pull
~~~

Verificar o status do reposit√≥rio para ver as mudan√ßas realizadas:
~~~shell
git status
~~~

Se tudo estiver ok, adicionar os arquivos, comitar e por fim enviar para o reposit√≥rio remoto.
~~~shell
git add . 
git commit -m "Implementando o refresh do token e testes de autoriza√ß√£o." 
git push 
~~~




[üêç FIM VOLTAR DAQUI ...üêç]

# Aula 09 Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI
## Criando a migra√ß√£o da nova tabela
~~~shell
alembic revision --autogenerate -m "create todos table"
~~~

Depois que a migra√ß√£o for criada, precisamos aplic√°-la ao nosso banco de dados. Execute o comando alembic upgrade head para aplicar a migra√ß√£o.
~~~shell
alembic upgrade head
~~~



Atualizando o reposit√≥rio.
~~~shell
git add .
git commit -m "Implementado os endpoints de tarefas"
~~~


# Aula 10 Dockerizando a nossa aplica√ß√£o e introduzindo o PostgreSQL

## Criando nosso Dockerfile
Para criar um container Docker, escrevemos uma lista de passos de como construir o ambiente para execu√ß√£o da nossa aplica√ß√£o em um arquivo chamado Dockerfile. Ele define o ambiente de execu√ß√£o, os comandos necess√°rios para preparar o ambiente e o comando a ser executado quando um cont√™iner √© iniciado a partir da imagem.

Uma das coisas interessantes sobre Docker √© que existe um Hub de containers prontos onde a comunidade hospeda imagens "prontas", que podemos usar como ponto de partida. Por exemplo, a comunidade de python mant√©m um grupo de imagens com o ambiente python pronto para uso. Podemos partir dessa imagem com o python j√° instalado adicionar os passos para que nossa aplica√ß√£o seja executada.

Aqui est√° um exemplo de Dockerfile para executar nossa aplica√ß√£o:
~~~shell
FROM python:3.12-slim
ENV POETRY_VIRTUALENVS_CREATE=false

WORKDIR app/
COPY . .

RUN pip install poetry

RUN poetry config installer.max-workers 10
RUN poetry install --no-interaction --no-ansi

EXPOSE 8000
CMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app
~~~

## Criando a imagem
Para criar uma imagem Docker a partir do Dockerfile, usamos o comando docker build. O comando a seguir cria uma imagem chamada "fast_zero":
~~~shell
docker build -t "fast_zero" .
~~~

Ent√£o verificaremos se a imagem foi criada com sucesso usando o comando:
~~~shell
docker images
~~~

## Executando o container
~~~shell
docker run -it --name fastzeroapp -p 8000:8000 fast_zero:latest
~~~

~~~shell
curl http://localhost:8000
~~~

## Introduzindo o postgreSQL
~~~shell
docker run -d \
    --name app_database \
    -e POSTGRES_USER=app_user \
    -e POSTGRES_DB=app_db \
    -e POSTGRES_PASSWORD=app_password \
    -p 5432:5432 \
    postgres
~~~

No PostgreSQL, o diret√≥rio padr√£o para armazenamento de dados √© /var/lib/postgresql/data. Mapeamos esse diret√≥rio para um volume (neste caso "pgdata") em nossa m√°quina host para garantir a persist√™ncia dos dados:
~~~shell
docker run -d \
    --name app_database \
    -e POSTGRES_USER=app_user \
    -e POSTGRES_DB=app_db \
    -e POSTGRES_PASSWORD=app_password \
    -v pgdata:/var/lib/postgresql/data \
    -p 5432:5432 \
    postgres
~~~

## Adicionando o suporte ao PostgreSQL na nossa aplica√ß√£o
~~~shell
poetry add "psycopg[binary]"
~~~

Para ajustar a conex√£o com o PostgreSQL, modifique seu arquivo .env para incluir a seguinte string de conex√£o:
~~~shell
DATABASE_URL="postgresql+psycopg://app_user:app_password@localhost:5432/app_db"
~~~

Para que a instala√ß√£o do psycopg esteja na imagem docker, precisamos fazer um novo build. Para que a nova vers√£o do pyproject.toml seja copiada e os novos pacotes sejam instalados:
~~~shell
docker rm fastzeroapp 
docker build -t "fast_zero" 
docker run -it --name fastzeroapp -p 8000:8000 fast_zero:latest
~~~

~~~shell
docker exec -it fastzeroapp poetry run alembic upgrade head
~~~


## Simplificando nosso fluxo com docker-compose
Cria√ß√£o do compose.yaml
~~~shell
services:
  fastzero_database:
    image: postgres
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: app_user
      POSTGRES_DB: app_db
      POSTGRES_PASSWORD: app_password
    ports:
      - "5432:5432"

  fastzero_app:
    image: fastzero_app
    build: .
    ports:
      - "8000:8000"
    depends_on:
      - fastzero_database
    environment:
      DATABASE_URL: postgresql+psycopg://app_user:app_password@fastzero_database:5432/app_db

volumes:
  pgdata:
~~~

~~~shell
docker-compose up
~~~

## Implementando o Entrypoint
Criamos um script chamado entrypoint.sh que ir√° preparar nosso ambiente antes de a aplica√ß√£o iniciar:
~~~shell
#!/bin/sh

# Executa as migra√ß√µes do banco de dados
poetry run alembic upgrade head

# Inicia a aplica√ß√£o
poetry run uvicorn --host 0.0.0.0 --port 8000 fast_zero.app:app
~~~


## Adicionando o Entrypoint ao Docker Compose:

Inclu√≠mos o entrypoint no nosso servi√ßo no arquivo compose.yaml, garantindo que esteja apontando para o script correto:

compose.yaml
~~~shell
  fastzero_app:
    image: fastzero_app
    entrypoint: ./entrypoint.sh
    build: .
~~~

~~~shell
docker-compose up --build
~~~

~~~shell
docker-compose up -d fastzero_database
~~~

~~~shell
poetry add --group dev testcontainers
~~~





Atualizando o reposit√≥rio.
~~~shell
git add .
git commit -m "Dockerizando nossa aplica√ß√£o e inserindo o PostgreSQL"
git push
~~~


# Aula 11 Automatizando os testes com Integra√ß√£o Cont√≠nua (CI)
Configurando o workflow de CI
As configura√ß√µes dos workflows no GitHub Actions s√£o definidas em um arquivo YAML localizado em um path especificado pelo github no reposit√≥rio .github/workflows/. Dentro desse diret√≥rio podemos criar quantos workflows quisermos. Iniciaremos nossa configura√ß√£o com um √∫nico arquivo que chamaremos de pipeline.yaml:
~~~shell
name: Pipeline
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Instalar o python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
~~~


Para isso, devemos criar um step para cada uma dessas a√ß√µes no nosso job test. Desta:
`.github/workflows/pipeline.yaml`
~~~shell
    steps:
      - name: Instalar o python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Instalar o poetry
        run: pipx install poetry

      - name: Instalar depend√™ncias
        run: poetry install

      - name: Executar testes
        run: poetry run task test
~~~

Atualizando o reposit√≥rio.
~~~shell
git add .
git commit -m "Adicionando o checkout ao pipeline"
git push
~~~

## Configura√ß√£o de vari√°veis de ambiente no Actions
[...]

~~~shell
gh secret set -f .env
~~~

`.github/workflows/pipeline.yaml`
~~~shell
jobs:
  test:
    runs-on: ubuntu-latest

    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      SECRET_KEY: ${{ secrets.SECRET_KEY }}
      ALGORITHM: ${{ secrets.ALGORITHM }}
      ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}
~~~


Atualizando o reposit√≥rio.
~~~shell
git add .
git commit -m "Adicionando as vari√°veis de ambiente para o CI"
git push
~~~

# Aula 12 Fazendo deploy no Fly.io
[...]

~~~shell
git add .
git commit -m "Adicionando arquivos gerados pelo Fly"
git push
~~~

# Aula 13 Despedida e pr√≥ximos passos
[... ainda vai ter esta aula ...]


# Projeto final

---

XXX
~~~shell

~~~



~~~python
s = "Sintaxe do Pythong"
print s
~~~

    

